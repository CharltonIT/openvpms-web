/*
 * Version: 1.0
 *
 * The contents of this file are subject to the OpenVPMS License Version
 * 1.0 (the 'License'); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.openvpms.org/license/
 *
 * Software distributed under the License is distributed on an 'AS IS' basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * Copyright 2014 (C) OpenVPMS Ltd. All Rights Reserved.
 */

package org.openvpms.hl7.impl;

import ca.uhn.hl7v2.HL7Exception;
import ca.uhn.hl7v2.model.Message;
import ca.uhn.hl7v2.model.v25.datatype.DTM;
import ca.uhn.hl7v2.model.v25.segment.MSH;
import ca.uhn.hl7v2.protocol.ReceivingApplication;
import ca.uhn.hl7v2.protocol.ReceivingApplicationException;
import ca.uhn.hl7v2.protocol.ReceivingApplicationExceptionHandler;
import ca.uhn.hl7v2.protocol.Transportable;
import org.openvpms.hl7.io.Connector;
import org.openvpms.hl7.io.Statistics;

import java.util.Calendar;
import java.util.Date;
import java.util.Map;

/**
 * Listener for HL7 messages.
 * <p/>
 * TODO: timezones and milliseconds are included in messages if the receiver throws an exception or a nak is
 * generated by ApplicationRouterImpl.
 *
 * @author Tim Anderson
 */
class MessageReceiver implements ReceivingApplication, ReceivingApplicationExceptionHandler, Statistics {

    /**
     * The connector.
     */
    private final Connector connector;

    /**
     * The receiver to handle messages.
     */
    private final ReceivingApplication receiver;

    /**
     * Message configuration, used to format responses correctly.
     */
    private final MessageConfig config;

    /**
     * The timestamp of the last received message.
     */
    private Date lastReceived;

    /**
     * The time of the last failure, or {@code null} if the last receive was successful.
     */
    private Date lastError;

    /**
     * The error message, if processing the last message was unsuccessful.
     */
    private String lastErrorMessage;


    /**
     * Constructs an {@link MessageReceiver}.
     *
     * @param receiver  the receiver to delegate to
     * @param connector the connector
     */
    public MessageReceiver(ReceivingApplication receiver, Connector connector) {
        this.connector = connector;
        config = new MessageConfig();
        config.setIncludeMillis(connector.isIncludeMillis());
        config.setIncludeTimeZone(connector.isIncludeTimeZone());
        this.receiver = receiver;

    }

    /**
     * Returns the receiver to delegate messages to.
     *
     * @return the receiver
     */
    public ReceivingApplication getReceivingApplication() {
        return receiver;
    }

    /**
     * Uses the contents of the message for whatever purpose the application
     * has for this message, and returns an appropriate response message.
     *
     * @param theMessage  an inbound HL7 message
     * @param theMetadata message metadata (which may include information about where the message comes
     *                    from, etc).  This is the same metadata as in {@link Transportable#getMetadata()}.
     * @return an appropriate application response (for example an application ACK or query response).
     *         Appropriate responses to different types of incoming messages are defined by HL7.
     * @throws ReceivingApplicationException if there is a problem internal to the application (for example
     *                                       a database problem)
     * @throws HL7Exception                  if there is a problem with the message
     */
    @Override
    public Message processMessage(Message theMessage, Map<String, Object> theMetadata)
            throws ReceivingApplicationException, HL7Exception {
        Message message = receiver.processMessage(theMessage, theMetadata);
        if (!config.isIncludeMillis() || !config.isIncludeTimeZone()) {
            // correct the date/time format
            try {
                MSH msh = (MSH) message.get("MSH");
                DTM time = msh.getDateTimeOfMessage().getTime();
                Calendar calendar = time.getValueAsCalendar();
                PopulateHelper.populateDTM(time, calendar, config);
            } catch (HL7Exception ignore) {
                // do nothing
            }
        }
        processed();
        return message;
    }

    /**
     * Determines if the receiver can process a message.
     *
     * @param theMessage an inbound HL7 message
     * @return true if this ReceivingApplication wishes to accept the message.  By returning
     *         true, this Application declares itself the recipient of the message, accepts
     *         responsibility for it, and must be able to respond appropriately to the sending system.
     */
    @Override
    public boolean canProcess(Message theMessage) {
        return receiver.canProcess(theMessage);
    }

    /**
     * Process an exception.
     *
     * @param incomingMessage  the incoming message. This is the raw message which was received from the external
     *                         system
     * @param incomingMetadata Any metadata that accompanies the incoming message.
     * @param outgoingMessage  the outgoing message. The response NAK message generated by HAPI.
     * @param e                the exception which was received
     * @return The new outgoing message. This can be set to the value provided by HAPI in {@code outgoingMessage},
     *         or may be replaced with another message. <b>This method may not return {@code null}</b>.
     */
    @Override
    public String processException(String incomingMessage, Map<String, Object> incomingMetadata,
                                   String outgoingMessage, Exception e) throws HL7Exception {
        error(e.getMessage());
        return outgoingMessage;
    }

    /**
     * Returns the number of messages in the queue.
     *
     * @return {@code 0} - the receiver doesn't support queuing
     */
    @Override
    public int size() {
        return 0;
    }

    /**
     * Returns the time when a message was last successfully received or sent.
     *
     * @return the time when a message was last successfully sent, or {@code null} if none have been sent
     */
    @Override
    public synchronized Date getProcessedTimestamp() {
        return lastReceived;
    }

    /**
     * Returns the time of the last error.
     *
     * @return the time of the last error, or {@code null} if the last message was successfully processed
     */
    @Override
    public synchronized Date getErrorTimestamp() {
        return lastError;
    }

    /**
     * Returns the last error message, if the last send was unsuccessful.
     *
     * @return the last error message. May be {@code null}
     */
    @Override
    public synchronized String getErrorMessage() {
        return lastErrorMessage;
    }

    /**
     * Returns the connector used to send messages via this queue.
     *
     * @return the connector
     */
    @Override
    public Connector getConnector() {
        return connector;
    }

    /**
     * Invoked when a message is successfully processed.
     */
    private synchronized void processed() {
        lastReceived = new Date();
        lastError = null;
        lastErrorMessage = null;
    }

    /**
     * Invoked when a message cannot be processed,
     *
     * @param message the error message
     */
    private synchronized void error(String message) {
        lastError = new Date();
        lastErrorMessage = message;
    }

}
